{"remainingRequest":"E:\\项目\\FoodProductManageSystem\\Frontend\\node_modules\\vue-loader\\lib\\index.js??vue-loader-options!E:\\项目\\FoodProductManageSystem\\Frontend\\node_modules\\vue-baidu-map\\components\\overlays\\Circle.vue?vue&type=script&lang=js&","dependencies":[{"path":"E:\\项目\\FoodProductManageSystem\\Frontend\\node_modules\\vue-baidu-map\\components\\overlays\\Circle.vue","mtime":499162500000},{"path":"E:\\项目\\FoodProductManageSystem\\Frontend\\node_modules\\cache-loader\\dist\\cjs.js","mtime":499162500000},{"path":"E:\\项目\\FoodProductManageSystem\\Frontend\\node_modules\\babel-loader\\lib\\index.js","mtime":499162500000},{"path":"E:\\项目\\FoodProductManageSystem\\Frontend\\node_modules\\cache-loader\\dist\\cjs.js","mtime":499162500000},{"path":"E:\\项目\\FoodProductManageSystem\\Frontend\\node_modules\\vue-loader\\lib\\index.js","mtime":499162500000}],"contextDependencies":[],"result":["\nimport commonMixin from '../base/mixins/common.js'\nimport bindEvents from '../base/bindEvent.js'\nimport {createPoint} from '../base/factory.js'\n\nexport default {\n  name: 'bm-circle',\n  render () {},\n  mixins: [commonMixin('overlay')],\n  props: {\n    center: {\n    },\n    radius: {\n    },\n    strokeColor: {\n      type: String\n    },\n    strokeWeight: {\n      type: Number\n    },\n    strokeOpacity: {\n      type: Number\n    },\n    strokeStyle: {\n      type: String\n    },\n    fillColor: {\n      type: String\n    },\n    fillOpacity: {\n      type: Number\n    },\n    massClear: {\n      type: Boolean,\n      default: true\n    },\n    clicking: {\n      type: Boolean,\n      default: true\n    },\n    editing: {\n      type: Boolean,\n      default: false\n    }\n  },\n  watch: {\n    'center.lng' (val, oldVal) {\n      const {BMap, originInstance, isEditing, disableEditing, enableEditing, center, editing} = this\n      if (!isEditing) {\n        disableEditing()\n        const lng = val\n        if (val.toString() !== oldVal.toString() && lng >= -180 && lng <= 180) {\n          originInstance.setCenter(createPoint(BMap, {lng, lat: center.lat}))\n        }\n        editing && enableEditing()\n      }\n    },\n    'center.lat' (val, oldVal) {\n      const {BMap, originInstance, isEditing, disableEditing, enableEditing, center, editing} = this\n      if (!isEditing) {\n        disableEditing()\n        const lat = val\n        if (val.toString() !== oldVal.toString() && lat >= -74 && lat <= 74) {\n          originInstance.setCenter(createPoint(BMap, {lng: center.lng, lat}))\n        }\n        editing && enableEditing()\n      }\n    },\n    radius (val, oldVal) {\n      const {originInstance, isEditing, disableEditing, enableEditing, editing} = this\n      if (!isEditing) {\n        disableEditing()\n        originInstance.setRadius(val)\n        editing && enableEditing()\n      }\n    },\n    strokeColor (val) {\n      this.originInstance.setStrokeColor(val)\n    },\n    strokeOpacity (val) {\n      this.originInstance.setStrokeOpacity(val)\n    },\n    strokeWeight (val) {\n      this.originInstance.setStrokeWeight(val)\n    },\n    strokeStyle (val) {\n      this.originInstance.setStrokeStyle(val)\n    },\n    fillColor (val) {\n      this.originInstance.setFillColor(val)\n    },\n    fillOpacity (val) {\n      this.originInstance.setFillOpacity(val)\n    },\n    editing (val) {\n      val ? this.enableEditing() : this.disableEditing()\n    },\n    massClear (val) {\n      val ? this.originInstance.enableMassClear() : this.originInstance.disableMassClear()\n    },\n    clicking (val) {\n      this.reload()\n    }\n  },\n  methods: {\n    dragStartHandler () {\n      this.isEditing = true\n    },\n    dragEndHandler () {\n      this.isEditing = false\n      this.bindEditingNodeEvents()\n    },\n    bindEditingNodeEvents () {\n      const {originInstance, editingKey, dragStartHandler, dragEndHandler} = this\n      originInstance[editingKey].forEach($node => {\n        $node.addEventListener('dragstart', dragStartHandler)\n        $node.addEventListener('dragend', dragEndHandler)\n      })\n    },\n    enableEditing () {\n      const {originInstance, bindEditingNodeEvents} = this\n      originInstance.enableEditing()\n      bindEditingNodeEvents()\n    },\n    disableEditing () {\n      const {originInstance} = this\n      originInstance.disableEditing()\n    },\n    getEditingKey (overlay) {\n      const stack = []\n      overlay.enableEditing()\n      setTimeout(() => {\n        for (const key in overlay) {\n          if (overlay[key] && overlay[key].length === 2) {\n            stack.push(key)\n          }\n        }\n        overlay.disableEditing()\n        for (const key in overlay) {\n          if (overlay[key] && overlay[key].length === 0 && ~stack.indexOf(key)) {\n            this.editingKey = key\n          }\n        }\n      }, 0)\n    },\n    load () {\n      const {BMap, map, center, radius, strokeColor, strokeWeight, strokeOpacity, strokeStyle, fillColor, fillOpacity, editing, massClear, clicking, enableEditing, disableEditing, getEditingKey, editingKey} = this\n      const overlay = new BMap.Circle(createPoint(BMap, {lng: center.lng, lat: center.lat}), radius, {\n        strokeColor,\n        strokeWeight,\n        strokeOpacity,\n        strokeStyle,\n        fillColor,\n        fillOpacity,\n        // enableEditing: editing,\n        enableMassClear: massClear,\n        enableClicking: clicking\n      })\n      this.originInstance = overlay\n      map.addOverlay(overlay)\n      bindEvents.call(this, overlay)\n      // 解决圆形组件无法双向绑定的问题\n      !editingKey && getEditingKey(overlay)\n      setTimeout(() => {\n        editing ? enableEditing() : disableEditing()\n      }, 0)\n    }\n  }\n}\n",{"version":3,"sources":["Circle.vue"],"names":[],"mappings":";AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"Circle.vue","sourceRoot":"node_modules/vue-baidu-map/components/overlays","sourcesContent":["<script>\nimport commonMixin from '../base/mixins/common.js'\nimport bindEvents from '../base/bindEvent.js'\nimport {createPoint} from '../base/factory.js'\n\nexport default {\n  name: 'bm-circle',\n  render () {},\n  mixins: [commonMixin('overlay')],\n  props: {\n    center: {\n    },\n    radius: {\n    },\n    strokeColor: {\n      type: String\n    },\n    strokeWeight: {\n      type: Number\n    },\n    strokeOpacity: {\n      type: Number\n    },\n    strokeStyle: {\n      type: String\n    },\n    fillColor: {\n      type: String\n    },\n    fillOpacity: {\n      type: Number\n    },\n    massClear: {\n      type: Boolean,\n      default: true\n    },\n    clicking: {\n      type: Boolean,\n      default: true\n    },\n    editing: {\n      type: Boolean,\n      default: false\n    }\n  },\n  watch: {\n    'center.lng' (val, oldVal) {\n      const {BMap, originInstance, isEditing, disableEditing, enableEditing, center, editing} = this\n      if (!isEditing) {\n        disableEditing()\n        const lng = val\n        if (val.toString() !== oldVal.toString() && lng >= -180 && lng <= 180) {\n          originInstance.setCenter(createPoint(BMap, {lng, lat: center.lat}))\n        }\n        editing && enableEditing()\n      }\n    },\n    'center.lat' (val, oldVal) {\n      const {BMap, originInstance, isEditing, disableEditing, enableEditing, center, editing} = this\n      if (!isEditing) {\n        disableEditing()\n        const lat = val\n        if (val.toString() !== oldVal.toString() && lat >= -74 && lat <= 74) {\n          originInstance.setCenter(createPoint(BMap, {lng: center.lng, lat}))\n        }\n        editing && enableEditing()\n      }\n    },\n    radius (val, oldVal) {\n      const {originInstance, isEditing, disableEditing, enableEditing, editing} = this\n      if (!isEditing) {\n        disableEditing()\n        originInstance.setRadius(val)\n        editing && enableEditing()\n      }\n    },\n    strokeColor (val) {\n      this.originInstance.setStrokeColor(val)\n    },\n    strokeOpacity (val) {\n      this.originInstance.setStrokeOpacity(val)\n    },\n    strokeWeight (val) {\n      this.originInstance.setStrokeWeight(val)\n    },\n    strokeStyle (val) {\n      this.originInstance.setStrokeStyle(val)\n    },\n    fillColor (val) {\n      this.originInstance.setFillColor(val)\n    },\n    fillOpacity (val) {\n      this.originInstance.setFillOpacity(val)\n    },\n    editing (val) {\n      val ? this.enableEditing() : this.disableEditing()\n    },\n    massClear (val) {\n      val ? this.originInstance.enableMassClear() : this.originInstance.disableMassClear()\n    },\n    clicking (val) {\n      this.reload()\n    }\n  },\n  methods: {\n    dragStartHandler () {\n      this.isEditing = true\n    },\n    dragEndHandler () {\n      this.isEditing = false\n      this.bindEditingNodeEvents()\n    },\n    bindEditingNodeEvents () {\n      const {originInstance, editingKey, dragStartHandler, dragEndHandler} = this\n      originInstance[editingKey].forEach($node => {\n        $node.addEventListener('dragstart', dragStartHandler)\n        $node.addEventListener('dragend', dragEndHandler)\n      })\n    },\n    enableEditing () {\n      const {originInstance, bindEditingNodeEvents} = this\n      originInstance.enableEditing()\n      bindEditingNodeEvents()\n    },\n    disableEditing () {\n      const {originInstance} = this\n      originInstance.disableEditing()\n    },\n    getEditingKey (overlay) {\n      const stack = []\n      overlay.enableEditing()\n      setTimeout(() => {\n        for (const key in overlay) {\n          if (overlay[key] && overlay[key].length === 2) {\n            stack.push(key)\n          }\n        }\n        overlay.disableEditing()\n        for (const key in overlay) {\n          if (overlay[key] && overlay[key].length === 0 && ~stack.indexOf(key)) {\n            this.editingKey = key\n          }\n        }\n      }, 0)\n    },\n    load () {\n      const {BMap, map, center, radius, strokeColor, strokeWeight, strokeOpacity, strokeStyle, fillColor, fillOpacity, editing, massClear, clicking, enableEditing, disableEditing, getEditingKey, editingKey} = this\n      const overlay = new BMap.Circle(createPoint(BMap, {lng: center.lng, lat: center.lat}), radius, {\n        strokeColor,\n        strokeWeight,\n        strokeOpacity,\n        strokeStyle,\n        fillColor,\n        fillOpacity,\n        // enableEditing: editing,\n        enableMassClear: massClear,\n        enableClicking: clicking\n      })\n      this.originInstance = overlay\n      map.addOverlay(overlay)\n      bindEvents.call(this, overlay)\n      // 解决圆形组件无法双向绑定的问题\n      !editingKey && getEditingKey(overlay)\n      setTimeout(() => {\n        editing ? enableEditing() : disableEditing()\n      }, 0)\n    }\n  }\n}\n</script>\n"]}]}